[{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2022 Proteomics.data.analysis authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/LFQ.html","id":"input-data","dir":"Articles","previous_headings":"","what":"Input data","title":"Label-free Quantification Proteomics","text":"start peptide-level output Proteome Discoverer (PD). experiment designed identify RNA-binding proteins (RBP) U-2 OS cell line using OOPS method (Queiroz et al. 2019) comparison RNase +/- used separate RBPs background non-specific proteins. 4 replicate experiments performed, RNase +/- experiments performed OOPS interface. LFQ run, approximately quantity peptides injected, based quantification peptide concentration post trypsin digestion. data published aim experiment equivalent Figure 2e original OOPS paper(Queiroz et al. 2019). data use available package. simply PeptideGroups.txt file PD read memory using read.delim(<PeptideGroups.txt>\"), <PeptideGroups.txt> path PeptideGroups file. can explore structure input data using str. see data.frame() 7808 rows 41 columns. important columns us : Sequence: sequence peptide Modifications: detected peptide modifications, including variable, e.g induced modifications oxidation Master.Protein.Accessions: assigned master protein(s) Abundance.F*.Sample: Columns peptide intensities samples analysed follows:","code":"pep_data <- lfq_all_oops_rnase_pep str(pep_data) #> 'data.frame':    7808 obs. of  41 variables: #>  $ Peptide.Groups.Peptide.Group.ID                      : int  3 103128 103062 103059 103056 103049 103048 103045 102936 102916 ... #>  $ Checked                                              : chr  \"False\" \"False\" \"False\" \"False\" ... #>  $ Confidence                                           : chr  \"High\" \"High\" \"High\" \"High\" ... #>  $ Sequence                                             : chr  \"AAAAAAAAAAAAAAAGAGAGAK\" \"LVKPGNQNTQVTEAWNK\" \"LVGSVNLFSDENVPR\" \"LVGSQEELASWGHEYVR\" ... #>  $ Modifications                                        : chr  \"\" \"\" \"\" \"\" ... #>  $ Qvality.PEP                                          : num  4.27e-07 8.31e-04 1.36e-03 7.92e-04 1.87e-06 ... #>  $ Qvality.q.value                                      : num  0.00026 0.00026 0.00026 0.00026 0.00026 ... #>  $ Number.of.Protein.Groups                             : int  1 1 1 1 1 1 1 1 1 1 ... #>  $ Number.of.Proteins                                   : int  1 1 1 1 1 1 1 1 1 1 ... #>  $ Number.of.PSMs                                       : int  8 8 4 8 16 7 26 12 10 11 ... #>  $ Master.Protein.Accessions                            : chr  \"P55011\" \"Q9UQ80\" \"Q9BQG0\" \"Q13200\" ... #>  $ Protein.Accessions                                   : chr  \"P55011\" \"Q9UQ80\" \"Q9BQG0\" \"Q13200\" ... #>  $ Number.of.Missed.Cleavages                           : int  0 0 0 0 0 1 0 0 0 1 ... #>  $ Theo.MHplus.in.Da                                    : num  1597 1927 1646 1960 1515 ... #>  $ Abundance.F17.Sample                                 : num  1927597 3768782 NA NA 6090638 ... #>  $ Abundance.F18.Sample                                 : num  3540084 6682988 NA NA 12042683 ... #>  $ Abundance.F19.Sample                                 : num  3466165 14879391 NA NA 19815360 ... #>  $ Abundance.F20.Sample                                 : num  789214 1826370 NA NA 3435918 ... #>  $ Abundance.F21.Sample                                 : num  1425166 NA NA NA 1736376 ... #>  $ Abundance.F22.Sample                                 : num  2515468 1258701 NA NA 2838919 ... #>  $ Abundance.F23.Sample                                 : num  2426854 1511282 NA NA 3298768 ... #>  $ Abundance.F24.Sample                                 : num  1370120 819806 NA NA 1711976 ... #>  $ Quan.Info                                            : chr  \"\" \"\" \"NoQuanValues\" \"NoQuanValues\" ... #>  $ Found.in.Sample.in.S17.F17.Sample                    : chr  \"High\" \"High\" \"High\" \"High\" ... #>  $ Found.in.Sample.in.S18.F18.Sample                    : chr  \"High\" \"High\" \"High\" \"High\" ... #>  $ Found.in.Sample.in.S19.F19.Sample                    : chr  \"High\" \"High\" \"Not Found\" \"High\" ... #>  $ Found.in.Sample.in.S20.F20.Sample                    : chr  \"High\" \"High\" \"Not Found\" \"Not Found\" ... #>  $ Found.in.Sample.in.S21.F21.Sample                    : chr  \"High\" \"Not Found\" \"Not Found\" \"Not Found\" ... #>  $ Found.in.Sample.in.S22.F22.Sample                    : chr  \"High\" \"High\" \"Not Found\" \"Not Found\" ... #>  $ Found.in.Sample.in.S23.F23.Sample                    : chr  \"High\" \"Peak Found\" \"Not Found\" \"High\" ... #>  $ Found.in.Sample.in.S24.F24.Sample                    : chr  \"High\" \"Peak Found\" \"Not Found\" \"Not Found\" ... #>  $ Confidence.by.Search.Engine.MS.Amanda.20             : chr  \"n/a\" \"High\" \"High\" \"High\" ... #>  $ Confidence.by.Search.Engine.Sequest.HT               : chr  \"High\" \"High\" \"High\" \"High\" ... #>  $ Percolator.q.Value.by.Search.Engine.MS.Amanda.20     : num  NA 0.000358 0.000434 0.000347 0.000434 ... #>  $ Percolator.q.Value.by.Search.Engine.Sequest.HT       : num  0.00041 0.000469 0.000457 0.00041 0.000469 ... #>  $ Percolator.PEP.by.Search.Engine.MS.Amanda.20         : num  NA 3.76e-04 6.54e-04 3.47e-04 1.06e-06 ... #>  $ Percolator.PEP.by.Search.Engine.Sequest.HT           : num  3.16e-07 3.91e-04 3.71e-04 1.21e-03 1.69e-06 ... #>  $ Amanda.Score.by.Search.Engine.MS.Amanda.20           : num  NA 45.4 81.1 65.3 132.2 ... #>  $ CharmeRT.Combined.Score.by.Search.Engine.MS.Amanda.20: num  NA 45.4 81.1 65.3 132.2 ... #>  $ XCorr.by.Search.Engine.Sequest.HT                    : num  5.77 3 4.34 4.37 3.85 5.92 3.09 4.3 2.92 3.58 ... #>  $ Top.Apex.RT.in.min                                   : num  65.7 57.8 NA NA 66.6 ... sample_data <- data.frame(   File = paste0(\"F\", 17:24),   Sample = paste0(rep(c(\"RNase_neg\", \"RNase_pos\"), each = 4), \".\", 1:4),   Condition = rep(c(\"RNase_neg\", \"RNase_pos\"), each = 4),   Replicate = rep(1:4, 2) )  knitr::kable(sample_data)"},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/LFQ.html","id":"parse-input-data-and-remove-contaminants","dir":"Articles","previous_headings":"Input data","what":"Parse input data and remove contaminants","title":"Label-free Quantification Proteomics","text":"start parse input data, need identify contaminant proteins, supplied Proteome Discoverer. want remove data. defined using cRAP database. , parse cRAP FASTA extract IDs cRAP proteins, ‘cRAP’ format UniProt accessions proteins completely sure remoing cRAP. , file use cRAP_20190401.fasta.gz available camprotR package. can supply cRAP protein IDs camprotR::parse_features() remove features (.e. peptides case) may originate contaminants, well features don’t unique master protein. See ?parse_features details, including removal ‘associated cRAP’ conservative contaminants removal. , can see started 7808 ‘features’ (peptides) 1463 master proteins across samples. removal contaminants peptides can’t assigned unique master protein, 7250 peptides remaining 1307 master proteins.","code":"crap_fasta_inf <- system.file(   \"extdata\", \"cRAP_20190401.fasta.gz\",    package = \"camprotR\" )  # Load the cRAP FASTA used for the PD search crap_fasta <- Biostrings::fasta.index(crap_fasta_inf, seqtype = \"AA\")  # Extract the UniProt accessions associated with each cRAP protein crap_accessions <- crap_fasta %>%    pull(desc) %>%    stringr::str_extract_all(pattern=\"(?<=\\\\|).*?(?=\\\\|)\") %>%    unlist() pep_data_flt <- camprotR::parse_features(   pep_data,   TMT = FALSE,    level = 'peptide',   crap_proteins = crap_accessions,  ) #> Parsing features... #> 7808 features found from 1463 master proteins => Input #> 242 cRAP proteins supplied #> 364 proteins identified as 'cRAP associated' #> 7509 features found from 1414 master proteins => cRAP features removed #> 7476 features found from 1396 master proteins => associated cRAP features removed #> 7471 features found from 1395 master proteins => features without a master protein removed #> 7250 features found from 1307 master proteins => features with non-unique master proteins removed"},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/LFQ.html","id":"convert-to-msnset","dir":"Articles","previous_headings":"Input data","what":"Convert to MSnSet","title":"Label-free Quantification Proteomics","text":"now store filtered peptide data MSnSet, standard data object proteomics R. See vignette(\"msnset\", package=\"camprotR\") details.","code":"# Create expression matrix with peptide abundances (exprs) and human  # readable column names exprs_data <- pep_data_flt %>%    select(matches(\"Abundance\")) %>%    `colnames<-`(sample_data$Sample) %>%    as.matrix()  # Create data.frame with sample metadata (pData) pheno_data <- sample_data %>%    select(-File) %>%    tibble::column_to_rownames(var = \"Sample\")  # Create data.frame with peptide metadata (fData) feat_data <- pep_data_flt %>%    select(-matches(\"Abundance\"))  # Create MSnSet pep <- MSnbase::MSnSet(exprs = exprs_data,                        fData = feat_data,                        pData = pheno_data)"},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/LFQ.html","id":"qc-peptides","dir":"Articles","previous_headings":"Input data","what":"QC peptides","title":"Label-free Quantification Proteomics","text":"First , want inspect peptide intensity distributions. expect approximately equal low intensity sample concern need explored. , can see clear variability, sample low intensity. Peptide intensities Next, consider missing values. Note MSnbase::plotNA assumes object contains protein-level data names x-axis accordingly. , update plot aesthetics rename x-axis , 7250 peptides, just 2085 quantification values 8 samples. surprise LFQ, since sample prepared run separately. Data completeness, peptides can explore structure missing values using ‘upset’ plot. Missing values upset plot case, can see common missing value patterns : Missing just RNase negative replicate 4 Missing samples. Missing samples, except RNase negative replicate 4 RNase negative replicate 4 slightly lower overall petide intensities appears somewhat outlier. case, retain sample cases, may warrant exploration potentially removal sample. Finally, recode abundances binary (present/absent) plot missing data structure heatmap (missing = black). Beyond aforementioned observations regarding RNase negative replicate 4, ’s clear structure missing values. expect LFQ, data largely missing random (MAR). methods impute values MAR, , providing protein-level abundance, usually appropriate perform protein inference using method can accommodate missing values. Presence/Absence heatmap","code":"pep %>%   log(base = 2) %>%   camprotR::plot_quant(method = 'density') #> Warning: Removed 19289 rows containing non-finite values (stat_density). p <- MSnbase::plotNA(pep, pNA = 0) +   camprotR::theme_camprot(border = FALSE, base_family = 'sans', base_size = 10) +   labs(x = 'Peptide index') print(p) missing_data <- pep %>%   exprs() %>%   data.frame()  naniar::gg_miss_upset(missing_data,                       sets = paste0(colnames(pep), '_NA'),                       keep.order = TRUE,                       nsets = 10) missing_data[!is.na(missing_data)] <- 1 missing_data[is.na(missing_data)] <- 0  gplots::heatmap.2(   as.matrix(missing_data),   col = c(\"black\", \"lightgray\"),   scale = \"none\", # Don't re-scale the input   # Default is euclidean, which is less appropriate distance for binary vectors   distfun = function(x) dist(x, method = 'binary'),    trace = \"none\", # Don't include a trace. Improves appearance   key = FALSE, # Don't include a key as values are binary   Colv = FALSE, # Don't re-order the columns   labRow = FALSE, # Don't label the rows   cexCol = 0.7 # Reduce the column name size ) #> Warning in gplots::heatmap.2(as.matrix(missing_data), col = c(\"black\", #> \"lightgray\"), : Discrepancy: Colv is FALSE, while dendrogram is `both'. Omitting #> column dendogram."},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/LFQ.html","id":"normalise-peptide-intensities","dir":"Articles","previous_headings":"Input data","what":"Normalise peptide intensities","title":"Label-free Quantification Proteomics","text":"injected quantity peptides sample, ’s reasonable normalise samples one another. apply ‘center-median’ normalisation, MSnbase::normalise called ‘diff.median’. Since peptide intensities log-Gaussian distributed, log2-transform performing normalisation. Protein intensities post-normalisation","code":"pep_norm <- pep %>%    log(base = 2) %>%    MSnbase::normalise('diff.median')    pep_norm %>%    camprotR::plot_quant(method = 'density') #> Warning: Removed 19289 rows containing non-finite values (stat_density)."},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/LFQ.html","id":"summarising-to-protein-level-abundance","dir":"Articles","previous_headings":"Input data","what":"Summarising to protein-level abundance","title":"Label-free Quantification Proteomics","text":"can summarise protein-level abundances, need exclude peptides many missing values. , peptides 5/8 missing values discarded, using MSnbase::filterNA(). also need remove proteins without least two peptides. use camprotR::restrict_features_per_protein() replace quantification values NA sample two quantified peptides given protein. Note means repeat filtering process since adding missing values. can re-inspect missing values. Note reduced overall number peptides 4971. Data completeness, retained peptides can now summarise protein-level abundance. , use ‘robust’ summarisation (Sticker et al. 2020) MSnbase::combineFeatures(). returns warning missing values can ignore since robust method inherently designed handle missing values. See MsCoreUtils::robustSummary() publication details robust method. can re-inspect missing values protein level. , quantification 681 proteins, 409 fully quantified across 8 samples. common missing values pattern remains missing just RNase negative replicate 4.   now obtained protein-level abundances LFQ data. recommended procedure summarising peptide protein level abundances.","code":"pep_restricted <- pep_norm %>%   MSnbase::filterNA(pNA = 4/8) %>% # Maximum 4/8 missing values   camprotR::restrict_features_per_protein(min_features = 2, plot = FALSE) %>% # At least two peptides per protein   # Repeat the filtering since restrict_features_per_protein will replace some values with NA   MSnbase::filterNA(pNA = 4/8) %>%    camprotR::restrict_features_per_protein(min_features = 2, plot = FALSE) p <- MSnbase::plotNA(pep_restricted, pNA = 0) +   camprotR::theme_camprot(border = FALSE, base_family = 'sans', base_size = 15) +   labs(x = 'Peptide index') print(p) prot_robust <- pep_restricted %>%   MSnbase::combineFeatures(     # group the peptides by their master protein id     groupBy = fData(pep_restricted)$Master.Protein.Accessions,      method = 'robust',      maxit = 1000  # Ensures convergence for MASS::rlm   )  #> Your data contains missing values. Please read the relevant section in #> the combineFeatures manual page for details on the effects of missing #> values on data aggregation. p <- MSnbase::plotNA(prot_robust, pNA = 0) +   camprotR::theme_camprot(border = FALSE, base_family = 'sans', base_size = 15) print(p) naniar::gg_miss_upset(data.frame(exprs(prot_robust)),                       sets = paste0(colnames(prot_robust), '_NA'),                       keep.order = TRUE,                       nsets = 10)"},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/LFQ.html","id":"alternatives-for-summarising-to-protein-level-abundance---maxlfq","dir":"Articles","previous_headings":"Input data","what":"Alternatives for summarising to protein-level abundance - MaxLFQ","title":"Label-free Quantification Proteomics","text":"Although recommend using ‘robust’ summarisation, algorithms commonly applied. example MaxLFQ (Cox et al. 2014), implemented within MaxQuant, also available via iq::maxLFQ() function iq package R (now available CRAN). , use iq::maxLFQ() manually, though possible use function within MSnbase::combineFeatures() theory since accommodates user-defined functions. can now compare protein-level abundance estimates. Comparison protein inference methods good overall correlation. Let’s inspect proteins largest differences two approaches see ’s going edge cases. define function plot peptide protein abundances two methods single protein. can ignore details since ’s plots interested . apply function proteins interest.      Looking examples, can see MaxLFQ often estimating slightly higher abundances similar profile across samples similar, summarisation approach unlikely affect downstream analysis. ’s clear two approaches correct examples , publication proposing robust protein inference (see ) indicate gives accurate fold-change estimates overall. now processed peptide-level LFQ abundances obtained protein-level abundances, can perform downstream analyses.","code":"# You may wish to retain more feature columns that this!  feature_coloumns_to_retain <- c(\"Master.Protein.Accessions\")  # To ensure we are only comparing the protein inference method and not normalisation etc, # we will use the same set of peptides for both inference methods pep_data_for_summarisation <- pep_restricted %>%   exprs() %>%   data.frame() %>%   merge(fData(pep_restricted)[, feature_coloumns_to_retain, drop = FALSE],          by = 'row.names') %>%   select(-Row.names) # Define a function to perform MaxLFQ on a single protein and return a data.frame # as required.  get_maxlfq_estimate <- function(obj) {   prot <- iq::maxLFQ(as.matrix(obj))$estimate      data.frame(t(prot)) %>%      setNames(colnames(obj)) }  # Group by the features we want to retain and use MaxLFQ on each protein maxlfq_estimates <- pep_data_for_summarisation %>%   group_by(across(all_of(feature_coloumns_to_retain))) %>%   dplyr::group_modify(~ get_maxlfq_estimate(.)) %>%   ungroup()  # Create the protein-level MSnSet maxlfq.e <- as.matrix(select(maxlfq_estimates, -Master.Protein.Accessions)) maxlfq.f <- data.frame(select(maxlfq_estimates, Master.Protein.Accessions)) maxlfq.p <- pData(pep_restricted)  prot_maxlfq <- MSnSet(exprs = maxlfq.e,                       fData = maxlfq.f,                       pData = maxlfq.p)  # Update the rownames to be the protein IDs rownames(prot_maxlfq) <- maxlfq_estimates$Master.Protein.Accessions # Define a function to extract the protein abundances in long form and # add a column annotating the method get_long_form_prot_exp <- function(obj, method_name) {   tidy(obj) %>%     mutate(method = method_name) }  # Single object with protein inference from both methods  compare_protein_abundances <- rbind(   get_long_form_prot_exp(prot_maxlfq, 'MaxLFQ'),   get_long_form_prot_exp(prot_robust, 'Robust') )  # Plot direct comparison compare_protein_abundances %>%   pivot_wider(names_from = method, values_from = value) %>% # pivot to wider form for plotting   ggplot(aes(x = Robust, y = MaxLFQ)) +   geom_point(alpha = 0.25, size = 0.5) +   theme_camprot(border = FALSE, base_family = 'sans', base_size = 15) +   geom_abline(slope = 1, colour = get_cat_palette(2)[2], linetype = 2, size = 1) # Identify proteins with largest difference between the protein summarisation methods proteins_of_interest <- compare_protein_abundances %>%   pivot_wider(names_from = method, values_from = value) %>%   mutate(diff = MaxLFQ-Robust) %>%   arrange(desc(abs(diff))) %>%   pull(protein) %>%   unique() %>%   head(5) plot_pep_and_protein <- function(protein_of_interest) {      to_plot_compare <- compare_protein_abundances %>%      filter(protein == protein_of_interest)      pep_restricted[fData(pep_restricted)$Master.Protein.Accession == protein_of_interest] %>%     exprs() %>%     data.frame() %>%     tibble::rownames_to_column('id') %>%     pivot_longer(cols = -id) %>%     ggplot(aes(x = name, y = value)) +     geom_line(aes(group = id), colour = 'grey', alpha = 0.5) +     geom_point(colour = 'grey', alpha = 0.5) +     geom_line(data = to_plot_compare,               aes(x = sample.id, y = value, colour = method, group = method)) +     geom_point(data = to_plot_compare,                aes(x = sample.id, y = value, colour = method)) +     scale_colour_manual(values = get_cat_palette(2), name = 'LFQ summarisation method') +     theme_camprot(base_size = 15, border = FALSE, base_family = 'sans') +     theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +     labs(       title = protein_of_interest,       x = '',       y = 'Protein abundance (log2)'     ) } proteins_of_interest %>% lapply(plot_pep_and_protein) #> [[1]] #>  #> [[2]] #>  #> [[3]] #>  #> [[4]] #>  #> [[5]]"},{"path":[]},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/LFQ.html","id":"alternative-normalisation---using-reference-proteins","dir":"Articles","previous_headings":"TOM - MOVE THIS SECTION TO AN OPTIONAL ‘EXTENSION’ notebook","what":"Alternative normalisation - Using reference proteins","title":"Label-free Quantification Proteomics","text":"Finally, consider alternative normalisation approach strong prior expectation abundance subset proteins. data RNase +/- OOPS experiment. Since OOPS known enrich glycoproteins interface, can use proteins internal set ‘housekeeping’ proteins expect difference abundance RNase +/-. First, need calculate RNase +/- ratios, since value want normalise. applications, may wish normalise abundance estimates sample, rather ratio samples. Next, need annotations regarding proteins glycoproteins GO-annotated RBPs. [notebook added cover GO annotations, reference avoid repeating explanations want expand set GO anntotations] Get GO terms proteins querying UniProt programmatically. Add feature columns describing glycoprotein GO-RBP status proteins. , define function plot ratios functional sub-type proteins. protein ratios look pre-normalisation…  OK, glycoproteins centered zero GO-annotated RBPs negative log RNase -/+ ratios (much ~25% replicate 2) , perform center median normalisation set reference proteins (, glycoproteins). plot protein ratios post-normalisation.  Now, median log2 RNase -/+ ratio glycoproteins zero replicates far fewer GO-annotated RBPs negative log RNase -/+ ratios.","code":"ratios <- exprs(prot_robust[,pData(prot_robust)$Condition == 'RNase_neg']) -    exprs(prot_robust[,pData(prot_robust)$Condition == 'RNase_pos'])  prot_ratios <- MSnSet(exprs = ratios,                       fData = fData(prot_robust),                       pData = (pData(prot_robust) %>% filter(Condition == 'RNase_neg'))) up_url <- \"https://www.uniprot.org/uploadlists/\"  request <- list(   query = paste(rownames(prot_robust), collapse = \" \"),   from = \"ACC+ID\",   to = \"ACC\",   format = \"tab\",   columns = paste(\"id\", \"features\", \"go-id\", sep = \",\") )  response <- httr::GET(url = up_url, query = request)  res <- httr::content(response, type = \"text\", encoding = \"UTF8\") %>%    read.table(text = ., sep = \"\\t\", header = TRUE) %>%    select(Entry, Features, Gene.ontology.IDs) go_long <- res %>%    separate_rows(Gene.ontology.IDs, sep = \"; \")  # This step may take a minute or two go_all <- get_ancestor_go(   go_long,    feature_col = \"Entry\",   go_col = \"Gene.ontology.IDs\",   verbose = TRUE ) #>  #> 'select()' returned 1:1 mapping between keys and columns #> [1] \"Getting all ancestor GO terms for 4396 observed terms. This may take a while!\" #> Expanding GO terms to include all ancestors for all entries #> 'select()' returned 1:1 mapping between keys and columns # Get RBPs go_rbp <- \"GO:0003723\"  rbps <- go_all %>%    filter(Gene.ontology.IDs == go_rbp) %>%    pull(Entry) # Get glycoproteins glycoproteins <- res %>%    filter(grepl(\"Glycosylation\", Features)) %>%   mutate(Glyco.features = Features) %>%   separate_rows(Glyco.features, sep = \"; \") %>%   filter(grepl(\"Glycosylation\", Glyco.features)) %>%   mutate(Glyco.features = gsub(\"\\\\(|\\\\)\", \"\", Glyco.features)) %>%   separate(Glyco.features, into = c(NA, \"Glycosylation.count\"), sep = \" \") %>%   select(Entry, Glycosylation.count) fData(prot_ratios) <- fData(prot_ratios) %>%   mutate(Glycoprotein = rownames(prot_ratios) %in% glycoproteins$Entry) %>%   mutate(GO.RBP = rownames(prot_ratios) %in% rbps) %>%   mutate(Glyco.RBP = interaction(Glycoprotein, GO.RBP)) %>%   mutate(Glyco.RBP = factor(recode(     Glyco.RBP,     'TRUE.TRUE'='GO:RBGP',     'FALSE.TRUE'='GO:RBP',     'TRUE.FALSE'='Glycoprotein',     'FALSE.FALSE'='Other'),     levels = c('GO:RBP', 'GO:RBGP', 'Other', 'Glycoprotein'))   ) plot_ratios <- function(obj) {   to_plot <- merge(     exprs(obj),     fData(obj)[,'Glyco.RBP',drop = FALSE],     by = 'row.names'   ) %>%     pivot_longer(cols = -c(Row.names, Glyco.RBP), names_to = 'sample', values_to = 'ratio') %>%     merge(pData(obj), by.x = 'sample', by.y = 'row.names') %>%     filter(is.finite(ratio))      p <- to_plot %>%      ggplot(aes(x = Replicate, y = ratio,                 group = interaction(Glyco.RBP, Replicate),                 colour = factor(Glyco.RBP))) +     geom_boxplot(position = position_dodge()) +     theme_camprot(border = FALSE, base_family = 'sans', base_size = 15) +     scale_colour_manual(values = c(get_cat_palette(3), 'black'), name = '') +     geom_hline(yintercept = 0, linetype = 2, colour = 'grey') +     labs(       x = \"Replicate\",       y = \"RNase -/+ ratio\"     )      print(p)      invisible(to_plot) } plot_ratios(prot_ratios) glycoprotein_medians <- prot_ratios[fData(prot_ratios)$Glyco.RBP == 'Glycoprotein',] %>%    camprotR::get_medians()  prot_ratios_norm <- camprotR::center_normalise_to_ref(   prot_ratios,   glycoprotein_medians,   center_to_zero = TRUE, # We want to center the glycoproteins around zero   on_log_scale = TRUE # The quantifications are on a log scale (log2 ratios) ) plot_ratios(prot_ratios_norm)"},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/LFQ.html","id":"session-info","dir":"Articles","previous_headings":"TOM - MOVE THIS SECTION TO AN OPTIONAL ‘EXTENSION’ notebook","what":"Session info","title":"Label-free Quantification Proteomics","text":"","code":"#> R version 4.1.3 (2022-03-10) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 20.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0 #> LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] tidyr_1.2.0                    dplyr_1.0.8                    #>  [3] Proteomics.data.analysis_0.1.0 camprotR_0.0.0.9000            #>  [5] biobroom_1.26.0                broom_0.8.0                    #>  [7] MSnbase_2.20.4                 ProtGenerics_1.26.0            #>  [9] S4Vectors_0.32.4               mzR_2.28.0                     #> [11] Rcpp_1.0.8.3                   Biobase_2.54.0                 #> [13] BiocGenerics_0.40.0            ggplot2_3.3.5                  #>  #> loaded via a namespace (and not attached): #>   [1] colorspace_2.0-3       ellipsis_0.3.2         visdat_0.5.3           #>   [4] rprojroot_2.0.3        XVector_0.34.0         fs_1.5.2               #>   [7] clue_0.3-60            farver_2.1.0           affyio_1.64.0          #>  [10] bit64_4.0.5            AnnotationDbi_1.56.2   fansi_1.0.3            #>  [13] codetools_0.2-18       ncdf4_1.19             doParallel_1.0.17      #>  [16] cachem_1.0.6           impute_1.68.0          robustbase_0.95-0      #>  [19] knitr_1.38             jsonlite_1.8.0         naniar_0.6.1           #>  [22] GO.db_3.14.0           cluster_2.1.3          vsn_3.62.0             #>  [25] png_0.1-7              BiocManager_1.30.16    compiler_4.1.3         #>  [28] httr_1.4.2             backports_1.4.1        assertthat_0.2.1       #>  [31] fastmap_1.1.0          limma_3.50.3           cli_3.2.0              #>  [34] htmltools_0.5.2        tools_4.1.3            gtable_0.3.0           #>  [37] glue_1.6.2             GenomeInfoDbData_1.2.7 affy_1.72.0            #>  [40] MALDIquant_1.21        jquerylib_0.1.4        pkgdown_2.0.2          #>  [43] vctrs_0.4.1            Biostrings_2.62.0      preprocessCore_1.56.0  #>  [46] iterators_1.0.14       xfun_0.30              stringr_1.4.0          #>  [49] lifecycle_1.0.1        iq_1.9.3               gtools_3.9.2           #>  [52] XML_3.99-0.9           DEoptimR_1.0-11        zlibbioc_1.40.0        #>  [55] MASS_7.3-56            scales_1.2.0           ragg_1.2.2             #>  [58] pcaMethods_1.86.0      parallel_4.1.3         yaml_2.3.5             #>  [61] curl_4.3.2             memoise_2.0.1          gridExtra_2.3          #>  [64] UpSetR_1.4.0           sass_0.4.1             stringi_1.7.6          #>  [67] RSQLite_2.2.12         highr_0.9              desc_1.4.1             #>  [70] foreach_1.5.2          caTools_1.18.2         BiocParallel_1.28.3    #>  [73] GenomeInfoDb_1.30.1    rlang_1.0.2            pkgconfig_2.0.3        #>  [76] systemfonts_1.0.4      bitops_1.0-7           mzID_1.32.0            #>  [79] evaluate_0.15          lattice_0.20-45        purrr_0.3.4            #>  [82] labeling_0.4.2         bit_4.0.4              tidyselect_1.1.2       #>  [85] plyr_1.8.7             magrittr_2.0.3         R6_2.5.1               #>  [88] IRanges_2.28.0         gplots_3.1.1           generics_0.1.2         #>  [91] DBI_1.1.2              pillar_1.7.0           withr_2.5.0            #>  [94] MsCoreUtils_1.6.2      KEGGREST_1.34.0        RCurl_1.98-1.6         #>  [97] tibble_3.1.6           crayon_1.5.1           KernSmooth_2.23-20     #> [100] utf8_1.2.2             rmarkdown_2.13         grid_4.1.3             #> [103] blob_1.2.3             digest_0.6.29          textshaping_0.3.6      #> [106] munsell_0.5.0          bslib_0.3.1"},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/LFQ.html","id":"references","dir":"Articles","previous_headings":"TOM - MOVE THIS SECTION TO AN OPTIONAL ‘EXTENSION’ notebook","what":"References","title":"Label-free Quantification Proteomics","text":"Cox, Jürgen, Marco Y. Hein, Christian . Luber, Igor Paron, Nagarjuna Nagaraj, Matthias Mann. 2014. “Accurate Proteome-Wide Label-Free Quantification Delayed Normalization Maximal Peptide Ratio Extraction, Termed MaxLFQ*.” Molecular & Cellular Proteomics 13 (9): 2513–26. https://doi.org/10.1074/mcp.M113.031591. Queiroz, Rayner M. L., Tom Smith, Eneko Villanueva, Maria Marti-Solano, Mie Monti, Mariavittoria Pizzinga, Dan-Mircea Mirea, et al. 2019. “Comprehensive Identification RNA–Protein Interactions Organism Using Orthogonal Organic Phase Separation (OOPS).” Nature Biotechnology 37 (2): 169. https://doi.org/10.1038/s41587-018-0001-2. Sticker, Adriaan, Ludger Goeminne, Lennart Martens, Lieven Clement. 2020. “Robust Summarization Inference Proteome-Wide Label-Free Quantification.” Molecular & Cellular Proteomics: MCP 19 (7): 1209–19. https://doi.org/10.1074/mcp.RA119.001624.","code":""},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/SILAC.html","id":"load-dependencies","dir":"Articles","previous_headings":"","what":"Load dependencies","title":"Processing and QC of SILAC data","text":"Load required libraries.","code":"library(Proteomics.data.analysis) library(camprotR) library(Biostrings) library(ggplot2) library(MSnbase) library(DEqMS) library(limma) library(dplyr) library(tidyr) library(tibble)"},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/SILAC.html","id":"preamble","dir":"Articles","previous_headings":"","what":"Preamble","title":"Processing and QC of SILAC data","text":"Stable Isotope Labelling /Amino acids Cell culture (SILAC) form quantitative proteomics different conditions quantified run differential metabolic labelling proteins using amino acids containing stable isotopes (Ong et al. 2002). typical SILAC experiment involved growing cells two different types SILAC media, one containing ‘light’ arginine lysine, containing ‘heavy’ arginine lysine. time cells incorporate light heavy amino acids proteins gives resulting downstream peptides different masses can detected LC-MS.Initially designed provide pairwise comparisons cell cultures, now extended two labels even whole organisms (Krüger et al. 2008). elegant experimental design enables quantification peptide/protein abundance ratios conditions little technical variation, since samples separate conditions pooled early possible sample handling process. Furthermore, use different isotope labels extended study turnover protein (e.g switch one label another) pulsed SILAC, relative turnover conditions (e.g two condition label switch condition different label; requires triple SILAC). analysis SILAC data relatively straightforward, since technical noise low normalisation normally required. Typically, one interested intensity (peak area peak height depending PD settings) ratio light (L) heavy (H) MS peaks given peptide. ratio forms quantification value wish perform statistical tests exploratory analysis .","code":""},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/SILAC.html","id":"asssessing-the-silac-isotope-incorporation-rate","dir":"Articles","previous_headings":"","what":"Asssessing the SILAC isotope incorporation rate","title":"Processing and QC of SILAC data","text":"performing SILAC experiment, necessary confirm complete (e.g > 95%) incorporation supplemented isotopically labelled amino acids cellular proteome. camprotR::estimate_incorporation() . Calculating incorporation given peptide simple, e.g H/(H+L) typical two label experiment. However, highly incorporated samples, true intensity L peptide ions close zero, can lead erroneous assignment ions L peptide. function supports calculation incorporation defined mixes heavy light labelled material, makes estimation incorporation rate robust since isotopes exist peptides. , heavy light labelled cells mixed 1:1. Importantly, note good correlation light heavy intensities, regardless whether either isotopes spectrum match (option mass shift relative peptide-spectrum match (PSM) cognate isotope). indicates quantification values true isotope pairs.  median observed incorporation mixed sample 50.8 peptide-level 50.5 protein level. Correcting mixing proportions gives us incorporation rate estimates just 100%, suggests true incorporation rate likely close 100%.","code":"# The cRAP fasta file for this experiment is part of the camprotR package. # Make sure to the use the same cRAP fasta that was used in PD for your experiment  crap_fasta_inf <- system.file(   \"extdata\", \"cRAP_20190401.fasta.gz\",    package = \"camprotR\" )  # psm_silac_p4 and pep_silac_p4 are loaded from the `camprotR` package  incorporation_results <- camprotR::estimate_incorporation(   # can replace with PD output using read.delim(PSMs.txt)   psm_input = psm_silac_p4,    # can replace with PD output using read.delim(PeptideGroups.txt)   peptide_input = pep_silac_p4,    crap_fasta = crap_fasta_inf,   mix = 1 # This incorporation test was performed with a 1:1 H/L mix ) #> camprotR::silac_psm_seq_int output has changed. #>   Columns indicating whether quantification is from PSM are now prefixed with #>   \"matched\", not \"Sequenced\", and tallys of PSMs per isotope are included. #>   Interference is not included by default (set include_interference=TRUE) #> Parsing features... #> 470 features found from 100 master proteins => Input #> 242 cRAP proteins supplied #> 0 proteins identified as 'cRAP associated' #> 470 features found from 100 master proteins => cRAP features removed #> 306 features found from 93 master proteins => features without quantification removed  print(incorporation_results$HL_correlation) print(incorporation_results$peptide_incorporation) #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. print(incorporation_results$protein_incorporation) #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`."},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/articles/SILAC.html","id":"processing-and-qc-of-silac-experimental-data","dir":"Articles","previous_headings":"","what":"Processing and QC of SILAC experimental data","title":"Processing and QC of SILAC data","text":"Now, onto experimental data. , process data OOPS (Queiroz et al. 2019) experiment designed identify proteins significantly enriched upon UV crosslinking (CL) vs non-crosslinked control cells (NC). RNA-binding proteins (RBPs) much abundant CL samples, since covalently crosslinks RBPs RNA, retains OOPS interface, sample taken. total, 4 SILAC runs, representing 4 separate plates U-2 OS cells. Two plates (replicate 1 & 2) Heavy CL two plates (replicates 3 & 4) Light CL. called ‘label’ swap/switch helps ensure results independent labelling scheme. first step read data remove contaminant proteins features without quantification data. defined using cRAP database. , parse cRAP FASTA extract IDs cRAP proteins, ‘cRAP’ format Uniprot IDs proteins. can supply cRAP protein IDs camprotR::parse_features remove features may originate contaminants, well features don’t unique master protein. See ?parse_features details, including removal ‘associated cRAP’. parse_features output messages number features stage filtering. Next, add new columns describe intensities respect CL NC conditions, based H & L map CL & NC replicate. added replicate number column previously, bind together rows replicates calculate CL/NC ratio using camprotR::get_ratio, also add missing column describe whether one quantification values missing. , tally plot missing values per replicate method. Note ~40% peptides missing quantification value ’s much likely missing NC CL. expect since OOPS method designed capture RBPs UV crosslinked RNA, without crosslinking, little protein present interface.   Next, plot distribution ratios. Note least two populations, clearest two : difference CL NC Higher abundance CL, modal CL:NC ratio around 6-fold expect population 1 proteins RBPs population 2 true RBPs.  can also consider relationship CL NC intensities. , see two populations, first dashed line (equality).  Given large number missing values, concern protein abundance NC may low , therefore, quantification values NC peptides identified mass shift rather peptide spectrum matching falsely assigning ions peptides. Note peptide sequences identified PSM referred ‘matched’ code blocks . get information quantification values come PSMs, need interrogate PSM-level output. use camprotR::silac_psm_seq_int identify quantification values PSMs. function also extracts interference/co-isolation value PSMs, available peptide-level output, though won’t use information . bind together spectrum matched data one data frame, ready merge peptide quantification. , merge quantification PSM information make new columns describe whether CL/NC quantification PSM. , consider often ratio comes peptide CL NC sequenced, just one sequenced, one therefore mass shift. Note minority peptides CL NC sequenced majority just sequenced CL.   can see consider CL vs NC correlation relates ‘sequenced’ information. Note correlation much poorer just CL sequenced. concern, since one plausible explanation many NC quantification values obtained CL identified spectrum matching, NC identified mass shift ions erroneously assigned peptide.  Whenever SILAC experiment performed complete absence protein one condition likely, recommended perform QC step. correlation poor just one condition spectrum matched, may necessary exclude peptides. vignette example, proceed peptides, retain information spectrum matching protein quantification, need investigate . Next, make MSnSet peptide-level CL/NC ratios. summarise peptide-level rations protein-level ratios. , ’ll use median demand least two ratios per protein.  Note summarisation occurring expression data, affect feature data (values first feature taken). want retain information whether peptide ‘matched’ conditions, need generate re-attach MSnSet. can now inspect completeness protein-level data using MSnbase::plotNA(). case 18/59 proteins complete data (4 replicates) expression matrix 63% complete overall.  identify proteins significantly increased abundance CL vs NC, use DEqMS (Zhu et al. 2020), can think extension limma (Ritchie et al. 2015) specifically proteomics. next step taken DEqMS vignette. idea want create MArrayLM object per normal limma analysis add $count column MArrayLM object use spectraCounteBayes function perform Bayesian shrinkage using count column rather $Amean column. case, count number peptides per protein. DEqMS paper, suggest best summarisation metric use minimum value across samples. Unfortunately, since proteins toy dataset, relationship PSM count variance apparent, though full-scale proteomics experiment.  , summarise number proteins statistically different abundance CL vs NC plot ‘volcano’ plot visualise . Note 24 proteins statistically significant change increased CL, plot looks like fire-hose volcano!  Finally, can explore export results. Importantly, $t, $P.Value $adj.P.Val columnts limma. columns prefixed sca DEqMS. Krüger, Marcus, Markus Moser, Siegfried Ussar, Ingo Thievessen, Christian . Luber, Francesca Forner, Sarah Schmidt, Sara Zanivan, Reinhard Fässler, Matthias Mann. 2008. “SILAC Mouse Quantitative Proteomics Uncovers Kindlin-3 Essential Factor Red Blood Cell Function.” Cell 134 (2): 353–64. https://doi.org/10.1016/j.cell.2008.05.033. Ong, Shao-En, Blagoy Blagoev, Irina Kratchmarova, Dan Bach Kristensen, Hanno Steen, Akhilesh Pandey, Matthias Mann. 2002. “Stable Isotope Labeling Amino Acids Cell Culture, SILAC, Simple Accurate Approach Expression Proteomics*.” Molecular & Cellular Proteomics 1 (5): 376–86. https://doi.org/10.1074/mcp.M200025-MCP200. Queiroz, Rayner M. L., Tom Smith, Eneko Villanueva, Maria Marti-Solano, Mie Monti, Mariavittoria Pizzinga, Dan-Mircea Mirea, et al. 2019. “Comprehensive Identification RNA–Protein Interactions Organism Using Orthogonal Organic Phase Separation (OOPS).” Nature Biotechnology 37 (2): 169. https://doi.org/10.1038/s41587-018-0001-2. Ritchie, Matthew E., Belinda Phipson, Di Wu, Yifang Hu, Charity W. Law, Wei Shi, Gordon K. Smyth. 2015. “Limma Powers Differential Expression Analyses RNA-Sequencing Microarray Studies.” Nucleic Acids Research 43 (7): e47. https://doi.org/10.1093/nar/gkv007. Zhu, Yafeng, Lukas M. Orre, Yan Zhou Tran, Georgios Mermelekas, Henrik J. Johansson, Alina Malyutina, Simon Anders, Janne Lehtiö. 2020. “DEqMS: Method Accurate Variance Estimation Differential Protein Expression Analysis.” Molecular & Cellular Proteomics : MCP 19 (6): 1047–57. https://doi.org/10.1074/mcp.TIR119.001646.","code":"# Load the cRAP FASTA used for the PD search crap_fasta <- Biostrings::fasta.index(crap_fasta_inf, seqtype = \"AA\")  # Define a base R version of stringr::str_extract_all() # to avoid loading the whole stringr package str_extract_all <- function(pattern, string) {   gregexpr(pattern, string, perl = TRUE) %>%      regmatches(string, .) %>%      unlist() }  # Extract the non-cRAP UniProt accessions associated with each cRAP protein crap_accessions <- crap_fasta %>%    pull(desc) %>%    str_extract_all(\"(?<=\\\\|).*?(?=\\\\|)\", .) %>%    unlist() # These files are part of the camprotR package pep_data <- list(pep_oops_1, pep_oops_2, pep_oops_3, pep_oops_4) names(pep_data) <- c('pep_1', 'pep_2', 'pep_3', 'pep_4')  pep_data_parsed <- lapply(   pep_data, function(infdata) {     parse_features(infdata,                    silac = TRUE,                    level = 'peptide',                    crap_proteins = crap_accessions,                    unique_master = FALSE)   } ) #> Parsing features... #> 550 features found from 101 master proteins => Input #> 242 cRAP proteins supplied #> 6 proteins identified as 'cRAP associated' #> 526 features found from 99 master proteins => cRAP features removed #> 525 features found from 98 master proteins => associated cRAP features removed #> 355 features found from 91 master proteins => features without quantification removed #> Parsing features... #> 547 features found from 101 master proteins => Input #> 242 cRAP proteins supplied #> 8 proteins identified as 'cRAP associated' #> 527 features found from 99 master proteins => cRAP features removed #> 525 features found from 98 master proteins => associated cRAP features removed #> 379 features found from 92 master proteins => features without quantification removed #> Parsing features... #> 580 features found from 101 master proteins => Input #> 242 cRAP proteins supplied #> 9 proteins identified as 'cRAP associated' #> 558 features found from 98 master proteins => cRAP features removed #> 558 features found from 98 master proteins => associated cRAP features removed #> 397 features found from 94 master proteins => features without quantification removed #> Parsing features... #> 683 features found from 102 master proteins => Input #> 242 cRAP proteins supplied #> 9 proteins identified as 'cRAP associated' #> 657 features found from 99 master proteins => cRAP features removed #> 655 features found from 98 master proteins => associated cRAP features removed #> 502 features found from 98 master proteins => features without quantification removed pep_data_parsed <- lapply(names(pep_data_parsed), function(experiment) {   # In this case, the replicate number is after the '_' so we extract like so   rep_n <- sapply(strsplit(experiment, split='_'), '[[', 2)       .data <- pep_data_parsed[[experiment]]      # Identify the column names for the light and heavy intensities   # (these names are not consistent between samples, yours may be different!)   abundance_light_col <- grep('Abundance.*.Light.Sample', colnames(.data), value = TRUE)   abundance_heavy_col <- grep('Abundance.*.Heavy.Sample', colnames(.data), value = TRUE)      # Label-swap info in cell above defines whether heavy or light is CL   cl_col <- ifelse(rep_n %in% 1:2, abundance_heavy_col, abundance_light_col)    nc_col <- ifelse(rep_n %in% 1:2, abundance_light_col, abundance_heavy_col)      .data <- .data %>%     # Add new columns with CL or NC intensities      mutate('CL' = !!sym(cl_col),            'NC' = !!sym(nc_col),            replicate = rep_n) %>%     # And subset to these columns     select(Master.Protein.Accessions, CL, NC, replicate, Sequence, Modifications)      return(.data) })  # Re-annotate with names names(pep_data_parsed) <- names(pep_data) abundance_data_complete <- do.call('rbind', pep_data_parsed) %>%    remove_rownames()  ratios <- abundance_data_complete %>%   filter((is.finite(CL) | is.finite(NC))) %>%   mutate(CL = log2(CL), NC = log2(NC)) %>%   get_ratio(CL, NC, bind = TRUE) ratios %>%   group_by(replicate, missing) %>%   tally() %>%   ggplot(aes(x = replicate, y = n, fill = missing)) +   geom_bar(stat = 'identity', position = 'fill', colour = 'grey50') +   theme_camprot(border = FALSE) +   labs(x = 'Replicate', y = 'Fraction') +    scale_fill_manual(values = get_cat_palette(3), name = '') ratios %>%   group_by(replicate, missing) %>%   tally() %>%   ggplot(aes(x = replicate, y = n, fill = missing)) +   geom_bar(stat = 'identity', position = 'stack', colour = 'grey50') +   theme_camprot(border = FALSE) +   labs(x = 'Replicate', y = 'Peptides') +    scale_fill_manual(values = get_cat_palette(3), name = '') ratios %>%    ggplot(aes(x = ratio, colour = replicate)) +   geom_vline(xintercept = 0, linetype = 2, colour = 'grey50') +   geom_density() +   theme_camprot(base_size = 15) +   labs(x = \"Ratio CL:NC (Log2)\", y = \"Density\", colour = \"Replicate\") +   scale_colour_manual(values = c(get_cat_palette(4))) #> Warning: Removed 638 rows containing non-finite values (stat_density). ratios %>%   ggplot(aes(x = CL, y = NC)) +   geom_point(aes(colour = replicate)) +   geom_abline(slope = 1, linetype = 2, colour = 'grey50') + # line at CL==NC   theme_camprot(base_size = 15, border = FALSE) +   scale_colour_manual(values = c(get_cat_palette(4))) #> Warning: Removed 638 rows containing missing values (geom_point). # These files are part of the camprotR package psm_data <- list(psm_oops_1, psm_oops_2, psm_oops_3, psm_oops_4) names(psm_data) <- c('psm_1', 'psm_2', 'psm_3', 'psm_4') psm_matched_data <- lapply(   psm_data, function(x) {     # If you export from PD including the 'Sequence' column,      # you don't need this step.     # Below, we convert the Annotated.Sequence column into a Sequence column     x$Sequence <- sapply(strsplit(x$Annotated.Sequence, split = '\\\\.'), '[[', 1) %>%       toupper()          camprotR::silac_psm_seq_int(x, sequence_col = 'Sequence')   } ) #> camprotR::silac_psm_seq_int output has changed. #>   Columns indicating whether quantification is from PSM are now prefixed with #>   \"matched\", not \"Sequenced\", and tallys of PSMs per isotope are included. #>   Interference is not included by default (set include_interference=TRUE) #> camprotR::silac_psm_seq_int output has changed. #>   Columns indicating whether quantification is from PSM are now prefixed with #>   \"matched\", not \"Sequenced\", and tallys of PSMs per isotope are included. #>   Interference is not included by default (set include_interference=TRUE) #> camprotR::silac_psm_seq_int output has changed. #>   Columns indicating whether quantification is from PSM are now prefixed with #>   \"matched\", not \"Sequenced\", and tallys of PSMs per isotope are included. #>   Interference is not included by default (set include_interference=TRUE) #> camprotR::silac_psm_seq_int output has changed. #>   Columns indicating whether quantification is from PSM are now prefixed with #>   \"matched\", not \"Sequenced\", and tallys of PSMs per isotope are included. #>   Interference is not included by default (set include_interference=TRUE) all_psm_matched_data <- psm_matched_data %>%   names() %>%   lapply(function(psm_name) {     rep_n <- sapply(strsplit(psm_name, split='_'), '[[', 2)      print(rep_n)     psm_matched_data[[psm_name]] %>%       mutate(replicate = rep_n)   }) %>%    bind_rows() #> [1] \"1\" #> [1] \"2\" #> [1] \"3\" #> [1] \"4\" # merge the matched information and add new columns for the CL/NC matched information ratios_matched <- ratios %>%   # Update the modifications column for the peptide object so it    # doesn't include SILAC modifications    mutate(Modifications = remove_silac_modifications(Modifications, level = 'peptide')) %>%   # Update the sequence column to all uppercase   rowwise() %>%    mutate(Sequence = toupper(Sequence)) %>%   # Merge with the sequenced information   merge(all_psm_matched_data,          by = c('Sequence', 'Modifications', 'replicate'))  %>%   # Add new columns with CL/NC and CL/NC matched information   mutate('Matched_CL' = ifelse(replicate %in% 1:2,                                   matched_Heavy, matched_Light),          'Matched_NC' = ifelse(replicate %in% 1:2,                                   matched_Light, matched_Heavy)) %>%   # And subset to these columns   select(Master.Protein.Accessions,          Sequence,           Modifications,          replicate,          ratio,          CL,           NC,          Matched_CL,          Matched_NC,          missing)  # Add a single column to describe the sequenced information ratios_matched <- ratios_matched %>%   mutate(     matched = interaction(Matched_CL, Matched_NC),     matched = factor(recode(matched,                             'TRUE.TRUE'='Both spectrum matched',                             'TRUE.FALSE'='CL spectrum matched',                             'FALSE.TRUE'='NC spectrum matched'),                       levels = c('Both spectrum matched',                                  'CL spectrum matched',                                  'NC spectrum matched'))   ) p <- ratios_matched %>%   filter(is.finite(ratio)) %>%   group_by(replicate, matched) %>%    tally() %>%   ggplot(aes(x = replicate, y = n, fill = matched)) +   theme_camprot(border = FALSE) +   scale_fill_manual(values = get_cat_palette(3), name = '') +   xlab('Replicate')  p1 <- p +   geom_bar(stat = 'identity', colour = 'grey50') +   ylab('Peptides')  print(p1) p2 <- p +   geom_bar(stat = 'identity', position = 'fill', colour = 'grey50') +   ylab('Fraction of peptides')  print(p2) ratios_matched %>%   filter(is.finite(CL), is.finite(NC)) %>%   group_by(matched) %>%   summarise(cor = cor(CL, NC)) #> # A tibble: 3 × 2 #>   matched                 cor #>   <fct>                 <dbl> #> 1 Both spectrum matched 0.554 #> 2 CL spectrum matched   0.409 #> 3 NC spectrum matched   0.613  ratios_matched %>%   ggplot(aes(x = CL, y = NC)) +   geom_point(aes(colour = replicate), size = 0.5) +   geom_abline(slope = 1, linetype = 2, colour = 'grey50') + # line at CL==NC   theme_camprot(base_size = 15, border = FALSE) +   facet_wrap(~ matched) +   scale_x_continuous(breaks = seq(14, 26, 4), limits = c(14, 26)) +   scale_y_continuous(breaks = seq(14, 26, 4), limits = c(14, 26)) +   scale_colour_manual(values = get_cat_palette(4)) #> Warning: Removed 628 rows containing missing values (geom_point). # Remove peptides without both CL + NC quantified flt_ratios <- ratios_matched %>%   filter(is.finite(ratio))  # Create a wide table with unique ids as row names flt_ratios_wide <- flt_ratios %>%    select(Master.Protein.Accessions, Sequence, Modifications,          replicate, Matched_NC, ratio) %>%    pivot_wider(names_from = \"replicate\", values_from = c(\"Matched_NC\", \"ratio\")) %>%    unite(id, Sequence, Modifications, remove = FALSE) %>%    column_to_rownames(var = \"id\")  # Create expression matrix (exprs) exprs_data <- flt_ratios_wide %>%    select(matches(\"ratio_[1-4]\")) %>% # select unique ids and ratio data   as.matrix()  # Create feature metadata data frame (fData) feat_data <- flt_ratios_wide %>%    select(!matches(\"ratio\")) # select unique ids and everything but ratio data  # Create MSnSet pep_res <- MSnSet(exprs = exprs_data, fData = feat_data)  # Add replicate number to phenotype data pData(pep_res)$Replicate <- 1:ncol(exprs_data)  pep_res #> MSnSet (storageMode: lockedEnvironment) #> assayData: 454 features, 4 samples  #>   element names: exprs  #> protocolData: none #> phenoData #>   sampleNames: ratio_1 ratio_2 ratio_4 ratio_3 #>   varLabels: Replicate #>   varMetadata: labelDescription #> featureData #>   featureNames: AAAAAAAAAAAAAAAGAGAGAK_ AAAAAAALQAK_ ... YVSSLTEEISK_ #>     (454 total) #>   fvarLabels: Master.Protein.Accessions Sequence ... Matched_NC_3 (7 #>     total) #>   fvarMetadata: labelDescription #> experimentData: use 'experimentData(object)' #> Annotation:   #> - - - Processing information - - - #>  MSnbase version: 2.20.4 # see ?camprotR::restrict_features_per_protein for more details # In particular, note that the function will replace some quantification values  # with NA, while removing some other peptides entirely pep_res_flt <- camprotR::restrict_features_per_protein(   pep_res,    min_features = 2,    plot = TRUE ) #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. prot_res <- combineFeatures(   pep_res_flt,    groupBy = fData(pep_res_flt)$Master.Protein.Accessions,   method = \"median\",   na.rm = TRUE ) #> Your data contains missing values. Please read the relevant section in #> the combineFeatures manual page for details on the effects of missing #> values on data aggregation.  print(nrow(pep_res)) #> [1] 454 print(nrow(pep_res_flt)) #> [1] 417 print(nrow((prot_res))) #> [1] 59 prot_matched_nc <- fData(pep_res_flt) %>%   select(-Sequence, -Modifications) %>%    pivot_longer(cols = -Master.Protein.Accessions, values_to = 'Matched_NC') %>%   group_by(Master.Protein.Accessions) %>%   filter(!is.na(Matched_NC)) %>%    summarise(any_not_sequenced = any(!Matched_NC))   fData(prot_res) <- fData(prot_res) %>%   rownames_to_column(var = \"id\") %>%    left_join(prot_matched_nc, by = \"Master.Protein.Accessions\") %>%    column_to_rownames(var = \"id\") MSnbase::plotNA(prot_res, pNA = 0) dat <- prot_res %>%    filterNA(pNA = 0.5) %>% # select proteins in min. 2/4 reps   exprs()  design <- cbind(Intercept = rep(1, ncol(dat)))  fit <- lmFit(dat, design) efit <- eBayes(fit)  # Obtain the min peptide count across the samples min_pep_count <- camprotR::count_features_per_protein(pep_res) %>%   group_by(Master.Protein.Accessions) %>%   summarise(min_pep_count = min(n))  # add the min peptide count efit$count <- min_pep_count %>%    filter(Master.Protein.Accessions %in% rownames(efit$coefficients)) %>%    pull(min_pep_count)  # run DEqMS efit_deqms <- suppressWarnings(spectraCounteBayes(efit)) # Diagnostic plots VarianceBoxplot(efit_deqms, n = 30, xlab = \"PSM count\") deqms_results <- outputResult(efit_deqms, coef_col = 1)  table(ifelse(deqms_results$sca.adj.pval < 0.01, 'sig.', 'not sig.'),       ifelse(deqms_results$logFC > 1, 'Higher in CL', 'Lower in CL')) #>            #>            Higher in CL Lower in CL #>   not sig.            1          19 #>   sig.               24           0  deqms_results %>%   ggplot(aes(x = logFC, y = -log10(sca.P.Value), colour = sca.adj.pval < 0.01)) +   geom_point() +   theme_camprot() +   scale_colour_manual(values = c('grey', get_cat_palette(2)[2]), name = 'CL vs NC Sig.') +   labs(x = 'CL vs NC (Log2)', y = '-log10(p-value)') head(deqms_results) #>           logFC  AveExpr         t      P.Value    adj.P.Val         B   gene #> P15880 5.843093 5.843093 19.119852 1.889018e-33 8.311680e-32 174.55385 P15880 #> Q92945 5.688033 5.688033 18.612464 1.310927e-32 2.884040e-31 165.03692 Q92945 #> P36578 3.775106 3.775106 12.352958 4.392638e-21 3.865522e-20  68.68522 P36578 #> P40429 3.126439 3.126439  8.859768 6.740128e-14 3.295174e-13  31.91773 P40429 #> P61254 4.865011 4.865011 11.256688 7.293579e-19 5.348624e-18  55.79930 P61254 #> O43390 5.876200 5.876200 16.652098 3.151435e-29 4.622105e-28 130.54854 O43390 #>        count    sca.t  sca.P.Value sca.adj.pval #> P15880     4 39.45864 1.101209e-37 4.845318e-36 #> Q92945     5 29.40900 6.460325e-32 1.421272e-30 #> P36578     3 20.64553 3.275304e-25 4.803779e-24 #> P40429     1 16.21849 1.187789e-20 1.306568e-19 #> P61254     1 14.41418 1.776341e-18 1.563180e-17 #> O43390     2 12.80037 9.098531e-17 6.672256e-16"},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tom Smith. Author, maintainer.","code":""},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Smith T (2022). Proteomics.data.analysis: Basic proteomics data analysis tutorials. R package version 0.1.0, https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/.","code":"@Manual{,   title = {Proteomics.data.analysis: Basic proteomics data analysis tutorials},   author = {Tom Smith},   year = {2022},   note = {R package version 0.1.0},   url = {https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/}, }"},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/index.html","id":"proteomicsdataanalysis","dir":"","previous_headings":"","what":"Basic proteomics data analysis tutorials","title":"Basic proteomics data analysis tutorials","text":"Proteomics.data.analysis package internal package written MRC Toxicology unit Proteomics bioinformaticsfacilities provide training basics proteomics analyses. assume user’s data processed Proteome Discoverer. Tutorials take form vignettes can viewed installing package navigating https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/","code":""},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/index.html","id":"install","dir":"","previous_headings":"","what":"Install","title":"Basic proteomics data analysis tutorials","text":"","code":"remotes::install_github(\"MRCToxBioinformatics/Proteomics_data_analysis/\", build_vignettes = TRUE)"},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/index.html","id":"how-to-use","dir":"","previous_headings":"","what":"How to use","title":"Basic proteomics data analysis tutorials","text":"Several HTML vignettes installed package go use different aspects package. can see list available vignettes :","code":"browseVignettes(\"Proteomics.data.analysis\")"},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/reference/hello.html","id":null,"dir":"Reference","previous_headings":"","what":"Hello, World! — hello","title":"Hello, World! — hello","text":"Prints 'Hello, world!'.","code":""},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/reference/hello.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hello, World! — hello","text":"","code":"hello()"},{"path":"https://mrctoxbioinformatics.github.io/Proteomics_data_analysis/reference/hello.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hello, World! — hello","text":"","code":"hello() #> Error in hello(): could not find function \"hello\""}]
